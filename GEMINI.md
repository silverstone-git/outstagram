# Outstagram Project Analysis

This document provides a detailed analysis of the Outstagram project, a FastAPI-based social media backend.

## 1. Project Overview

Outstagram is a social media application backend built with FastAPI. It provides APIs for user authentication, creating and managing posts, liking and commenting on posts, following other users, and fetching a personalized feed. It also includes a feature for users to submit and track exam results, promoting a balance between social and academic life. The project uses PostgreSQL for its database and SQLAlchemy with SQLModel for ORM. Docker is used for containerization.

## 2. Core Technologies

- **Backend Framework:** FastAPI
- **Database:** PostgreSQL
- **ORM:** SQLAlchemy with SQLModel
- **Authentication:** JWT with Argon2 for password hashing
- **API Schema Validation:** Pydantic
- **Containerization:** Docker, Docker Compose
- **Database Migrations:** Alembic

## 3. Project Structure

The project is organized into the following key directories:

- `lib/`: Contains the core application logic, including database models (`models.py`), Pydantic schemas (`schemas.py`), database connection setup (`database_connection.py`), custom exceptions (`exceptions.py`), and constants (`constants.py`).
- `src/repository/`: This directory holds the data access layer, with separate modules for handling different parts of the application:
    - `auth.py`: User registration, login, and JWT token management.
    - `posts.py`: Creating, retrieving, updating, deleting, and liking posts.
    - `comments.py`: Adding and retrieving comments on posts.
    - `frienship.py`: (Note the typo in the filename) Managing follow requests and friendships.
    - `users.py`: Fetching user profiles, dashboards, and user-specific posts.
    - `exams.py`: Retrieving paginated exam listings.
- `alembic/`: Manages database migrations.
- `main.py`: The main entry point of the FastAPI application, defining all the API endpoints.

## 4. Information Flow & Feature Implementation

### 4.1. User Authentication

1.  **Registration (`/register`):**
    - A new user is created via the `create_user` function in `src/repository/auth.py`.
    - The user's password is
    hashed using Argon2 before being stored in the database.
2.  **Login (`/login`):**
    - The `authenticate_user` function in `src/repository/auth.py` verifies the user's credentials.
    - If successful, a JWT access token is generated by `create_access_token`.
3.  **Authorization:**
    - Most endpoints are protected and require a valid JWT token.
    - The `get_current_user` dependency in `main.py` uses the `authorize` function from `src/repository/auth.py` to validate the token and retrieve the current user's information.

### 4.2. Posts

1.  **Creating a Post (`/posts`):**
    - The `create_post` function in `src/repository/posts.py` is called.
    - It creates a new `Post` object and associated `MediaURL` objects, saving them to the database.
2.  **Liking a Post (`/posts/{post_id}/like`):**
    - The `like_post_repo` function in `src/repository/posts.py` handles liking and unliking a post.
3.  **Commenting on a Post (`/posts/{post_id}/comment`):**
    - The `add_comment_repo` function in `src/repository/comments.py` adds a new comment to a post.

### 4.3. Social Features

1.  **Following a User (`/users/{username}/follow`):**
    - The `send_follow_request` function in `src/repository/frienship.py` creates a new `FollowRequest` with a "pending" status.
2.  **Approving a Follow Request (`/request-approve/{request_id}`):**
    - The `request_approve_repo` function in `src/repository/frienship.py` updates the `FollowRequest` status to "accepted" and creates a `Friendship` record.
3.  **Fetching the Feed (`/feed`):**
    - The `get_feed_repo` function in `src/repository/posts.py` retrieves posts from users that the current user follows, in reverse chronological order.

### 4.4. Exams

1.  **Creating an Exam (`/pariksha`):**
    - The `POST /pariksha` endpoint allows users to submit exam results.
    - It accepts an `exam_title` and `exam_json_str` in the request body.
    - A new `Exam` object is created with a unique `exam_id` (UUID) and saved to the database.
2.  **Retrieving Exams:**
    - `GET /pariksha`: Returns a paginated list of all exams. The `page` query parameter can be used to navigate through pages (e.g., `/pariksha?page=2`). This endpoint returns a summary of each exam, excluding the detailed `exam_json_str`.
    - `GET /pariksha/{exam_id}`: Returns a specific exam by its ID, including the `exam_json_str`.

### 4.5. Data Models and Schemas

- **`lib/models.py`:** Defines the SQLAlchemy models for `User`, `Post`, `PostComment`, `PostLike`, `MediaURL`, `FollowRequest`, `Friendship`, and `Exam`. These models map to the database tables.
- **`lib/schemas.py`:** Defines the Pantic schemas used for API request and response validation. This ensures that the data exchanged with the API conforms to the expected structure. This includes schemas like `UserSchema`, `PostSchema`, and `ExamSchema`.

## 5. Database

The `outstagram.sql` file contains the PostgreSQL database schema. The database uses a schema named `outsie`. The tables include:

- `user`: Stores user information.
- `post`: Stores post details.
- `postcomment`: Stores comments on posts.
- `postlike`: Stores likes on posts.
- `mediaurl`: Stores URLs for media associated with posts.
- `followrequest`: Manages follow requests between users.
- `friendship`: Represents the follower/following relationship.
- `exam`: Stores exam information, including a title and a JSON string with exam details.

Alembic is used for managing database schema migrations, as seen in the `alembic/` directory.

## 6. Deployment

The project is set up for Docker-based deployment.

- **`Dockerfile`:** Defines the Docker image for the application. It installs dependencies from `requirements.txt` and sets up the FastAPI server.
- **`docker-compose.yaml`:** Orchestrates the application service (`outsie`). It configures the Docker container, including port mappings and environment variables.

The `README.md` provides instructions for running the application both in a development environment and using Docker.

## 7. Development Notes

This section documents some of the challenges and solutions encountered during the development of the "exams" feature.

### 7.1. Database Migrations with Alembic

The process of adding the `Exam` table and modifying it involved several steps and troubleshooting.

1.  **Initial Setup:** The project was missing an `alembic.ini` file. A new one was created, but it couldn't expand environment variables for the `sqlalchemy.url`. The solution was to modify `alembic/env.py` to read the environment variables and programmatically set the database URL.

2.  **`ModuleNotFoundError`:** The `alembic` command initially failed because it couldn't find the `lib` module. This was resolved by adding the project's root directory to the Python path at the beginning of `alembic/env.py`:
    ```python
    import sys
    from pathlib import Path
    sys.path.append(str(Path(__file__).resolve().parents[1]))
    ```

3.  **`NameError` in Migration File:** When auto-generating the migration for the `Exam` table, the resulting migration script was missing the `import sqlmodel` statement, causing a `NameError`. This was fixed by manually adding the import to the migration file (`alembic/versions/0b590aee64c6_add_exam_title_to_exams_table.py`).

4.  **`IntegrityError` on Upgrade:** When adding the non-nullable `exam_title` column to the existing `exam` table (which already had data), the migration failed with an `IntegrityError` because the existing rows would have null values. The solution was to add a `server_default` value to the column definition in the migration script:
    ```python
    op.add_column('exam', sa.Column('exam_title', sqlmodel.sql.sqltypes.AutoString(), nullable=False, server_default='default_title'))
    ```

**Correct Migration Process:**

-   **Generate a migration:** `alembic revision --autogenerate -m "Your migration message"`
-   **Apply the migration:** `alembic upgrade head`

### 7.2. API Testing with cURL

When testing the `POST /pariksha` endpoint, there were issues with correctly formatting the JSON payload in the `curl` command.

-   **The Problem:** The `exam_json_str` field is a string that contains JSON. This requires careful escaping of quotes, especially on the command line where the shell also interprets quotes.

-   **Incorrect Command:**
    ```bash
    # This failed due to improper escaping of the inner JSON string
    curl -X POST -H "Content-Type: application/json" -d '{"exam_json_str": "{\"subject\": \"Maths\", \"marks\": 100}"}' http://localhost:8000/pariksha
    ```

-   **Correct Command:**
    ```bash
    curl -X POST -H "Content-Type: application/json" -d '{"exam_title": "Finals", "exam_json_str": "{\"subject\": \"Science\", \"marks\": 95}"}' http://localhost:8000/pariksha
    ```
-   **Why it worked:** The outer payload is enclosed in single quotes (`'`). The keys and string values within the JSON are enclosed in double quotes (`"`). The nested JSON string for `exam_json_str` also uses double quotes, which need to be escaped with a backslash (`\`) so they are treated as literal characters within the string.

### 7.3. Python Import Issues

During development, a `ModuleNotFoundError` occurred when running the application in Docker. The error, `No module named 'app.src.lib'`, originated from an incorrect relative import in the newly created `src/repository/exams.py` file.

-   **The Problem:** The import statement `from ..lib.models import Exam` was attempting to traverse up two directories from `exams.py` to find the `lib` directory. However, because of how the application was structured and run within the Docker container, this path was incorrect.

-   **The Solution:** The import path was corrected to `from ...lib.models import Exam`. This change adjusted the relative path to correctly locate the `lib` directory from within the `src` module, resolving the `ModuleNotFoundError` and allowing the application to start successfully.
